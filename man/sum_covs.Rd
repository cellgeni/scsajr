% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scsajr.R
\name{sum_covs}
\alias{sum_covs}
\title{Sum coverage and junction counts across a list of coverage objects}
\usage{
sum_covs(cov_list)
}
\arguments{
\item{cov_list}{A list of coverage objects. Each object must be a list with components:
\itemize{
\item \code{x}: a numeric vector of positions (shared across all objects),
\item \code{cov}: a numeric vector (or Rle) of coverage for those positions,
\item \code{juncs}: a data.frame with row names identifying junction IDs, at least three coordinate columns,
and a numeric \code{score} column.
}}
}
\value{
A single coverage object (list) with the same structure as the inputs:
\itemize{
\item \code{x}: the shared positions vector,
\item \code{cov}: the summed coverage across all inputs,
\item \code{juncs}: a data.frame containing the union of all junction coordinate rows
(first three columns) and a \code{score} column summing scores from each input.
}
}
\description{
Given a list of coverage objects, each containing:
\itemize{
\item \code{x}: a numeric vector of genomic positions,
\item \code{cov}: a numeric vector (or Rle) of coverage values at those positions,
\item \code{juncs}: a data.frame of junctions with at least three coordinate columns and a \code{score} column,
this function merges them by:
}
\enumerate{
\item Summing the coverage vectors (\code{cov}) across all objects (requires identical \code{x}).
\item Constructing a union of all junction coordinates (first three columns of each \code{juncs}),
initializing scores to zero, then adding each object’s \code{juncs$score} into the union table.
}
}
\details{
\enumerate{
\item Single‐element shortcut
If \code{length(cov_list) == 1}, the function simply returns \code{cov_list[[1]]} without modification.
\item Initialization
Let \code{r} be a copy of the first coverage object, i.e. the element at index 1 of \code{cov_list}.
Extract its \code{x}, \code{cov}, and \code{juncs} components for later aggregation.
\item Build the union of all junction coordinates
\itemize{
\item For each coverage object in \code{cov_list}, take the first three columns of its \code{juncs} data.frame.
\item Row‐bind them all together and then apply \code{unique()} to get every distinct coordinate triple.
\item Store these unique triples in a new data.frame called \code{all_juncs} and set \code{all_juncs$score <- 0}.
}
\item Accumulate scores from the first object
\itemize{
\item Match the row names of \code{r$juncs} against the row names of \code{all_juncs}.
\item For each matching row, add \code{r$juncs$score} into \code{all_juncs$score}.
}
\item Loop over remaining coverage objects
For each \code{current} in \code{cov_list[2:length(cov_list)]}:
\itemize{
\item Coverage sum
Check that \code{identical(r$x, current$x)}. If not, stop with an error. Otherwise, do

\if{html}{\out{<div class="sourceCode r">}}\preformatted{r$cov <- r$cov + current$cov
}\if{html}{\out{</div>}}
\item Junction score sum
For each junction ID (row name) in \code{current$juncs}, locate the matching row in \code{all_juncs}
(by shared row name). If found, add \code{current$juncs$score} to \code{all_juncs$score} at that row.
Junctions that do not appear in \code{current$juncs} simply contribute zero.
}
\item Finalize
After processing all objects, assign \code{r$juncs <- all_juncs} and return \code{r}.
}
}
